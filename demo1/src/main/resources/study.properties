#第一天(分布式框架dubbox)
#分布式框架dubbox,是一个远程服务调用框架,只有在分布式的时候，才有dubbox这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。
#
#方便远程服务调用
#
#高并发是一种现象,集群是解决高并发的一种方案,负载均衡也是高并发的解决方案,分布式是分开开发,分布成不同的部分,缓解开发压力
#
#高可用,在高并发的情况下还是可用.因为服务器可能在高并发的时候挂掉
#
#品优购采用b2b2c,商家可以入住
#
#业务最难部分在第六天和第七天
#
#采用的系统架构是SOA,面向服务的架构,实际上就是一种分布式架构,前端和业务逻辑分离
#
#采用技术:后端框架采用SSM+dubbox,前端采用angularJS+Bootstrap,有jsp就不是前后端编程了
#
#ZOOKEEP,树形的目录结构,适合作为Dubox服务的注册中心,装在linux系统上,把虚拟机当成服务器
#
#用secureCRT连接上linux,然后可以上传文件
#
#alt+p进入sftp界面
#
#记得用的包都是dubbox的,建立的包名字记得和扫描包的名字一样
#
#@Autowired本地注入,dubbox用另外一个@Reference的注入
#
#@RestControl = @Control+@ResponseBody(返回输出,还有一个别的是跳转页面)
#
#@Requestmapping请求映射,后面跟地址
#
#接口一般是jar类型,被web工程直接引用的用jar,tomcat直接运行的用war
#
#关于pojo里面实体类还要全部实现序列化接口(Serializable),必要要做因为实体类要在网络中传输要序列化,之前不用是因为在本地中传输所以不用
#
#第二天(AngularJS)
#
#AngularJS,版本1用的比较多,前端框架常用指令,品牌管理分页,品牌管理的增删改查
#
#四大特征:MVC模式,双向绑定,依赖注入,模块化设计
#
#双向绑定,模型与视图动态同步,修改一个变量,另一边也跟着改
#
#依赖注入,把一个bean传给另一个bean,不用new了
#
#模块化设计,一般用用户自定义模块,高内聚低耦合法则
#
#MVC思想,思想和jQ完全不同,把前端也mvc处理,Angular的思想是操作变量,然后绑定变量,jQ的思想是dom操作
#
#Model:数据,其实就是angular变量($scope.XX);
#
#View: 数据的呈现,Html+Directive(指令);
#
#Controller:操作数据,就是function,数据的增删改查;
#
#
#
#<body ng-app>这样才会识别表达式,ng-app是识别的指令,不然识别不了angularJS的表达式
#
#表达式:{{}}
#
#ng-model 指令用于绑定变量,这样用户在文本框输入的内容会绑定到变量上，而表达式可以实时地输出变量。
#
#ng-init指令,初始化指令
#
#控制器
#
#var app=angular.module('myApp',[]); //定义了一个叫myApp的模块,[]里面放的是其它模块
#
#
#
#通过模块来创建控制器.app.controller("myCpmtroller",function($scope){
#
#}),第一个参数控制器名称,第二个参数是控制器的内容,$scope控制层和视图层交换数据的桥梁
#
#<body ng-app="myApp" ng-controller="myController">识别模块名称
#
#事件指令ng-click  是最常用的单击事件指令，再点击时触发控制器的某个方法
#
#ng-repeat指令用于循环数组变量。
#
#内置服务,使用$http获取后端数据
#
#src的..找到根目录
#
#实体类和业务无关的包可以不用域名命名,entity,因为别的业务可以复用,不用改域名,比如页码这种
#
#要网络传输的bean要实现可序列化接口
#
#后端pojo改了的话,要用maven重新安装一下
#
#maven build 运行项目
#
#@RequestBody注解实现接收http请求的json数据，将json数据转换为java对象,一般用post传递对象
#
#$scope.selectIds.push(),push相当于集合里面的add方法
#
#第三天
#
#规格和模板管理
#
#将前端分层开发,把服务单独拿出来写,里面内容包括请求地址和传递参数,比如内置服务$http就是服务,把后端看成dao层,前端和后端交互的的桥梁
#
#再由控制层调用服务,然后直接返回
#
#然后在js文件夹下创建文件夹controller和service,做成文件放在js下面,然后导入html中
#
#控制器继承,将公共部分抽取出来,然后需要使用的继承,如分页和刷新
#
#里面使用的继承是一种伪继承,能实现类似继承的效果
#
#
#
#$controller也是angular提供的一个服务，实际上就是与BaseController共享$scope
#
#代码生成器
#
#做规格管理功能
#
#增加规格功能,初始化集合要先来一个空的[],里面集合用push增加,用splice移除,另外传输的集合pojo也要序列化
#
#修改,可以用先全删后结果全加,这样不用担心又有加又有删了的修改了
#
#在repeat中用$index自动获得索引
#
#用组合接收,不用sql关联,关联效率低
#
#select2下拉使用和位置的注意
#
#后端相当于dao,然后service一般是放链接,连接下后端,然后control调用service,然后html调用control
#
#AgularJS用Json.parse方法将string转成json,这里的json是js内置的,这个常用
#
#第四天(Spring Security安全框架,权限控制)
#
#Spring Security安全框架,权限控制
#
#完成商家登录,商家入住,商家审核
#
#access使用权
#
#在spring-security.xml的<http>标签写的是拦截的规则,有使用权的才能访问某路径
#
#里面的use-expressions,是否启动SPEL表达式,有两种写法,这个简单,另外一个是没有写use什么的,在aceess那里加个hasrole的方法再加role的名称
#
#<form-login>开启表单登录功能,接收html传过来的action地址,和接受完跳转的地址,还有失败跳转的页面,可以改登录的变量user或者password,也要设置总是跳转的默认页面
#
#<authentication-manager>认证管理器,用户里面添加角色,然后就可以访问某路径了
#
#在<http>中,使用security="none"不登录也可以访问
#
#X-CSRF-TOKEN防止csrf的拦截,除非是自己生产的页面,或者那个页面是jsp页面,像html本身是个静态的页面没办法添加token,所以得把这个功能关闭
#
#CSRF跨站请求伪造,是一种安全机制,是一种对网站的恶意利用,从这个站点访问另外一个站点,相当于攻击
#
#有的时候不一定是你的错误,可能是缓存的问题
#
#security默认拦截内置iframe,要去改个配置才能使用里面的功能
#
#配置policy策略就可以解决上面那个问题
#
#登入后同步账号显示
#
#<logout>注销,自动退出,也可以设置要跳转的网页
#
#商家申请入住
#
#<body>上初始化加入查询的时候设置状态码为未激活,就不用去后端弄那么麻烦了
#
#商家详情,更新商家状态
#
#用dubbo远程调用注入,写登录
#
#密码加密,比md5更高级的加密,不可逆的加密,哈希算法,md5,32位
#
#可逆(秘钥)
#
#bcrypt加密算法
#
#第五天(商品管理)
#
#商品录入(1)
#
#spu和sku,富文本编辑器,上传服务器FastDFS,掌握angularJS图片上传
#
#商品分类,3层级,和面包屑导航,树状结构
#
#一般先写dao,再写后端service在写serviceimpl在写control,再写前端service,再写前端control,在写html
#
#spu:如iphone7
#
#sku如红色电信64g的iphone7是一个sku
#
#一个spu对应多个sku
#
#商品录入功能goods商品基本信息spu,goodsdesc商品spu扩展,itemList商品spu列表
#
#RTE富文本编辑器,一般用KindEditor,里面实际上是html的内容
#
#上传图片
#
#分布式文件服务器FastDFS,阿里巴巴出的
#
#tracker管理集群
#
#maven工程的中央仓库不存在fastDFS
#
#第六天(商品管理)
#
#规格,扩展属性,选择商品分类
#
#需求分析,级联操作
#
#学另外一种下拉列表,除了select2这种
#
#使用ng-options指定<select>内容的指令里面有专门的语法 item指的是专门一条记录,再指定值和文本,很方便
#
#级联,使用变量监控方法
#
#$scope.$watch(),这是系统的方法,所以带$,变量监控
#
#json.parse将字符串转成json数据
#
#遇到错误,先分析是前端还是后端的问题,缩小范围
#
#编写通用方法,在集合中查询对象中某个属性值
#
#克隆技巧
#
#浅克隆
#
#深克隆,值一样,但是是两个对象
#
#前端的是使用b=JSON.parse(JSON.stringfy(a))
#
#如果前端的方法没有$scope,页面上不调用的话,可以不加$scope,调用也不用$scope,相当这个控制器的私有方法
#
#第七天(商品管理)
#
#商品修改与审核
#
#$location服务,参数传递封装,使得不会写在浏览器上
#
#?前要加# ，则是angularJS的地址路由的书写形式
#
#$location.search搜索页面所有参数并封装成数组
#
#新指令.ng-checked,根据值是否被勾选
#
#JSON.parse() 方法用于将一个 JSON 字符串转换为对象。
#
#表格删增后的更新一般采用删除后再插入新表
#
#manager-web运营商后台
#
#shop商家后台
#
#第八天(广告和缓存)
#
#广告和springdataredis
#
#新建项目,引入依赖,记得改端口(分布式架构)
#
#src/webapp下面放前端文件
#
#框架放在webapp下面的plugin
#
#control和service放在js里面
#
#用三目运算符开发广告首页
#
#springdataredis,经常访问的数据放在这里,在spring的配置中访问redis服务,是对jedis的封装
#
#集合操作和对象操作
#
#list集合操作,右压栈,效果最后加的元素排在后面,左压栈,最后加的元素排在前面
#
#比如a b c顺序插入,那么右压栈排序是{a,b,c}.左压栈是{c,b,a}
#
#hash在这里其实就是map
#实际使用,先查,后插入,再查
#
#更新缓存,先清除再加入
#
#第九天(做搜索)
#
#luncene本身是个类库,调用解决,本身是用java调用
#
#建立在luncene之上,solr搜索引擎的技术,是基于Lucene的全文搜索服务器
#
#Solr可以独立运行，运行在Jetty、Tomcat等这些Servlet容器中,可以把他看成nosql的数据库,强项是搜索速度快
#
#solr有个管理界面,通过管理界面可以查询Solr的配置和运行情况。
#
#Solr和Lucene的本质区别有以下三点：搜索服务器，企业级和管理。Lucene本质上是搜索库，不是独立的应用程序，而Solr是。Lucene专注于搜索底层的建设，而Solr专注于企业应用。Lucene不负责支撑搜索服务所必须的管理，而Solr负责。所以说，一句话概括Solr: Solr是Lucene面向企业搜索应用的扩展
#
#中文分析器:IK Analyzer,因为中文要分词啊,轻量级中文分词工具包,可以自己扩展词典
#
#这里的域field指的是数据库的字段,或者说列
#
#里面的required是非空的意思,就是必须要有值,index,是否根据字段搜出来,store是否存储
#
#一般不会用默认的field,根据需求来定
#
#复制域,不用stored,不是物理的复制,multiValued是true,相当于几个域的和,比如搜索框可能会搜标题,可能品牌,所以这两个要联合起来等
#
#动态域,用在规格(spec),很灵活,关系型数据库比较好的地方
#
#使用数据库查询没有分词效果,like又很低效,数据库搜索压力很大
#
#所以使用solr,里面放的是内容,是数据,从数据库导入到这里的索引库中,随着数据库的变化而变化,同步的关系,增删改成也要做,
#
#可以用官方类库solrJ(原理:http请求和响应)
#
#spring-data-jpa框架用于dao层
#
#Spring Data Solr框架(原理:官方类库的封装,在maven里面有依赖传递)
#
#手动请求solr,手动处理相应httpClient
#
#@field注解,用于实体类和域的对应关系
#
#存在则修改,不存在就保存,不能存id一样的
#
#配好域后,要重启solr的服务端
#
#solr部署配置,批量导入插件,比较复杂就帮不上忙了,用自己代码写
#
#从mybatis查出然后导入spring data solr里面
#
#用map表示动态域
#
#search依赖文件里面不连接数据库,链接solr就可以了
#
#web文件夹一般放静态原型和控制层
#
#用post提交对象
#
#reference注入对象
#
#在写搜索后端的时候有个注意事项,控制层搜索可能会超过一秒钟,和dubbox有关,可能会挂掉,所以注入服务对象的时候把超时时间timeout改到5000,也可以在服务的提供方加入超时,取决于你对时间的估计,一般来说推荐放在服务端,如果两端都设置了时间,那以控制层的为准
#
#第十天(高亮,品牌,规格,过滤查询)
#
#高亮很麻烦,今天都挺麻烦的
#
#后端加入标签后,不能显示是因为防止html攻击,是angularJS的问题
#
#使用$sce,angularJS信任策略解决,trustAsHtml方法,让它去解析,trust信任的意思
#
#也可以使用angularJS的过滤器,可以看成全局方法,一般写在base.JS里面
#
#ng-bind-html,指令用来显示html内容,然后用竖线调用信任
#
#使用分组查询
#
#一个分组页可能包含多个分组结果
#
#品牌和规格的数据,做缓存,思路如下
#
#根据商品分类名称key缓存模板ID(value)
#根据模板ID缓存模板表key的品牌列表(value)
#根据模板ID缓存模板表key的规格列表(value)
#
#过滤查询,今天都很复杂
#
#第十一天(搜索)
#
#按价格区间搜索
#
#搜索结果分页,不用控件,这样可以改变样式,更可控
#
#多关键字搜索
#
#排序功能
#
#split分割
#
#setoffset起始索引
#
#query.setoffset((pageNo-1)*pageSize),得到第某页的每条记录
#
#pagesize,页面大小(本页记录数)
#500:只要页面中显示的是500错误,则表示服务器出错，服务器的程序出错，此时必须查找代码
#404::表示页面没有发现错误,可能路径出错
#sort排序的对象,对排序的封装
#spring task 任务调度技术,几点几点干嘛,主要是订单排序的话,订单会一直更新
#销量排序不用总销量排序,评价是优先好评的排在前面,不是纯粹的评价数量相加,将不同评价加权不同
#隐藏产品列表
#同步搜索到首页
#更新索引库
#第十二天(商品详情页)
#Freemarker网页静态化解决方案,今天起每天一个新技术,以ftl结尾的文件
#新闻网站和门户网站用的多,新闻内容被静态化了,主要是为了减少数据库访问压力
#比如商品详情页就是为了减少访问数据库压力,提前生成好静态页面,另外利于SEO
#另外这样可以使用高性能的Nginx的web服务器来部署,Nginx可以承载5w的并发,但是只能使用静态页面,而tomcat只有几百
#原理:读取模板然后把插值用变量来替换,然后通过文件io的方式输出就完事了
#模板文件中四种元素
#
#1、文本，直接输出的部分
#
#2、注释，即<#--...-->格式不会输出
#
#3、插值（Interpolation）：即${..}部分,将使用数据模型中的部分替代输出
#
#4、FTL指令：FreeMarker指令，和HTML标记类似，名字前加#予以区分，不会输出。
#
#FTL指令,可以实现一些逻辑
#
#assign指令
#此指令用于在页面上定义一个变量
#
#include指令
#此指令用于模板文件的嵌套
#
#内建函数
#
#内建函数语法格式： 变量+?+函数名称
#
#判断某变量是否存在:“??”
#用法为:variable??,如果该变量存在,返回true,否则返回false
#
#累计积分：${point?c}
#
#当前日期：${today?date} <br>
#当前时间：${today?time} <br>
#当前日期+时间：${today?datetime} <br>
#日期格式化： ${today?string("yyyy年MM月")}
#
#转换JSON字符串为对象
#<#assign data=text?eval />
#
#缺失变量默认值:“!”
#
#${aaa!'-'}
#
#>或者gt:判断左边值是否大于右边值 ,或者括号括起来
#>=或者gte:判断左边值是否大于等于右边值
#<或者lt:判断左边值是否小于右边值
#<=或者lte:判断左边值是否小于等于右边值
#
#注意:  =和!=可以用于字符串,数值和日期来比较是否相等,但=和!=两边必须是相同类型的值,否则会产生错误,而且FreeMarker是精确比较,"x","x ","X"是不等的.其它的运行符可以作用于数字和日期,但不能作用于字符串,大部分的时候,使用gt等字母运算符代替>会有更好的效果,因为 FreeMarker会把>解释成FTL标签的结束字符,当然,也可以使用括号来避免这种情况,如:<#if (x>y)>
#
#@refernce,远程调用
#
#caption标题
#
#第十三天(消息中间件)
#
#消息中间件JMS,和JDBC类似的理解,都是接口规范.使用SpringJMS
#
#简单的说中间件就是软件,服务类的软件,可以实现相应的功能,介于应用和底层数据软件的关系,用来存储消息的软件平台,相当于快递的鸟箱,解决系统模块之间异步调用的关系,
#
#减少藕合
#
#常见消息中间件ActiveMQ,apache里面的
#
#搜索和页面生产使用,用在执行过程长,这些不需要返回结果
#
#两种消费传递
#
#ptp,点对点,中间有一个队列,可以一个生产者和一个消费者
#
#另一种是发布/订阅模式,一个生产者,多个消费者接受
#
#linux命令chmod755是在linux下设置文件权限的命令,具体数字等还有含义
#
#队列里面的消息
#
#pending待定的
#
#点对点一般适用于一次的(搜索)
#
#发布/订阅,用页面生成
#
#spring整合JMS
#
#一个监听容器只能干一个事
#
#一般都写在控制层,记得解除dubbox
#
#jmsTemplateSpring提供的JMS工具类，它可以进行消息发送、接收等
#
#一般来说注入
#
#JmsTemplate和Destination
#
#配置文件中:
#
#队列目的地的value要相等
#
#消息监听容器里面,要监听目的地,和监听类
#
#商品审核-导入Solr索引库的流程(点对点)
#
#1解耦删除之前的直接连接2导入依赖3增加配置文件spring-activemq.xml,里面放着目的地,里面的value是重点,jmsTemplate也是重点,然后修改web.xml
#
#然后写生产者代码并发送,然后写搜索服务,添加依赖,然后配置applicationContext-jms-consumer.xml,目的地,jmstemplate,还有监听容器的监听类和目的地注入是重点
#
#然后写代码,添加监听类,里面注入搜索服务,然后写代码监听到以后执行导入索引库
#
#商品删除-移除Solr索引库记录(点对点)
#
#在配置文件spring-activemq.xml中增加目的地,然后写发布订阅的代码,然后写搜索服务(消费者),添加目的地和监听容器,然后写监听类,注入搜索服务,接收到以后执行搜索
#
#商品审核-执行网页静态化
#
#添加依赖,配置中写目的地,发布消息,消费者的时候,先解除dubbox依赖,然后添加依赖,增加目的地和监听容器,然后注入服务,写监听类
#
#其它都差不多
#
#第十四天(springboot和短信解决,用阿里大于)
#
#开发短信微服务
#
#Spring Boot 并不是不对 Spring 功能上的增强，而是提供了一种快速使用 Spring 的方式。
#
#starter启动器,原理,依赖传递
#
#记得把jdk版本更新,springboot默认用1.6,写个配置属性1.7即可
#
#@SpringBootApplication其实就是以下三个注解的总和
#
#@Configuration： 用于定义一个配置类
#
#@EnableAutoConfiguration ：Spring Boot会自动根据你jar包的依赖来自动配置项目。
#
#@ComponentScan： 告诉Spring 哪个packages 的用注解标识的类 会被spring自动扫描并且装入bean容器。
#
#热部署!!!不需要重启服务器就可以读取你修改的代码!
#
#阿里大于,短信发送平台,阿里云旗下产品,原理就是网络调用
#
#sms短信
#
#微服务,带有轻量级的含义,构建一个独立于品优购的单独的短信工程
#
#springboot很适合开发微服务
#
#properties可以把字屏蔽,像密码一样换成别的码
#
#创建一个短信微服务,接受activeMQ,接收到以后发送短信
#
#用springboot和阿里大于,方便
#
#1创建引导类2创建配置文件3短信工具类4写监听类
#
#第十五天(单点登录sso,是解决方案)
#
#单点登录sso,登入后,登入状态同步到各个web项目
#
#原理:各个web应用系统获得用户已经登录的认证系统,认证系统会给使用者一张票(本质是cookie),使用者用票去各个系统,系统会拿票和认证系统验证
#
#分布式项目不可缺少sso
#
#CAS客户端和服务端,它的服务端也是web层上的不是服务层
#
#SSO单点登录访问流程主要有以下步骤：
#
#1. 访问服务：SSO客户端发送请求访问应用系统提供的服务资源。
#
#2. 定向认证：SSO客户端会重定向用户请求到SSO服务器。
#
#3. 用户认证：用户身份认证。
#
#4. 发放票据：SSO服务器会产生一个随机的Service Ticket。
#
#5. 验证票据：SSO服务器验证票据Service Ticket的合法性，验证通过后，允许客户端访问服务。
#
#6. 传输用户信息：SSO服务器验证票据通过后，传输用户认证结果信息给客户端。
#
#CAS也是使用java的spring开发的
#
#用https,安全,需要ssl的安全证书(要买的),这里CAS要去除https认证让CAS使用http认证(因为没钱买ssl啊,没办法用https),不然不会有一次登录到处可以用的效果
#
#对我们影响没有什么区别,是运维层面了,就是部署的时候会改配置等
#
#乱七八糟的配置很麻烦!!!
#
#所以用SpringSecurity集成
#
#入口点,有点像接口,这个配置很复杂
#
#今天实际上就是把tomcat里面的CAS的页面的登录的源换到你网页里面
#
#显示用户名得掌握,肯定用的上,
#
#第十六章(购物车的解决方案)
#
#购物车是web项目,调用购物车的服务
#
#用cookie和redis存购物车
#
#cookie本地购物车,没登录的时候存
#
#redis是账号里面存的
#
#写一个新的项目可以从用户项目中参考,因为里面的单点登录是相通的
#
#cookie在写在web层比较好
#
#orderitem购物车明细列表
#
#cart购物车对象
#
#业务逻辑最好放服务层
#
#好处是服务层可以公用,尽量写这里
#
#设置未登录的时为匿名角色
#
#存redis
#
#跳板页
#
#merge合并(购物车)
#
#第十七天
#
#跨域请求解决方案
#
#写订单结算
#
#当两个应用协议,以及主机地址(或域名),端口其中有一项不同,就认为他们的域是不同的,但是网页名不同没关系
#
#JS跨域,两个不同的域,在a的应用的js脚本中调用了b的后端地址
#
#默认情况下JS不能跨域的,为什么?因为安全啊,JSONP跨域跨域解决
#
#但是我们用流行的官方的跨域解决方案,CORS
#
#IE版本不能低于10
#
#服务端加头,客户端也要同意
#
#更方便的,使用springmvc注解
#
#为什么我的oerder表不让主键自增?
#
#对于互联网项目,可能某个表会占用很大的空间,让你服务器硬盘满了怎么办?
#
#数据库分片,把数据库进行拆分,通过数据库中间件进行链接,可以理解成数据库的集群
#
#如果采用数据库自增的话,可能会产生重复的id,数据库可能物理分离,但是逻辑是一个的
#
#分布式ID生成解决方案
#
#1UUID(不用,1太长2没发排序)
#
#2redis(产生自增的序号,主键的生成需要访问redis,对redis有依赖)
#
#3Oracle 数据库对象-序列(与表无关),只有数据库用oracle才能用
#
#4程序自己写算法(不重复),使用分布式ID生成器
#
#分布式ID生成器(推特写的),算法snowflake,雪花算法
#
#第十八天(微信支付)
#
#二维码生成插件qrious使用
#
#越细,安全级别越高
#
#用模式2
#
#appid：微信公众账号或开放平台APP的唯一标识
#mch_id：商户号  (配置文件中的partner)
#partnerkey：商户密钥
#sign:数字签名, 根据微信官方提供的密钥和一套算法生成的一个加密信息, 就是为了保证交易的安全性
#
#微信支付接口调用的整体思路：
#
#按API要求组装参数，以XML方式发送（POST）给微信支付接口（URL）,微信支付接口也是以XML方式给予响应。程序根据返回的结果（其中包括支付URL）生成二维码或判断订单状态。
#
#httpclient,模拟浏览器的行为
#
#第十九天
#
#秒杀是单独写的
#
#秒杀技术实现核心思想是运用缓存减少数据库瞬间的访问压力！读取商品详细信息时运用缓存，当用户点击抢购时减少缓存中的库存数量，当库存数为0时或活动期结束时，同步到数据库。 产生的秒杀预订单也不会立刻写到数据库中，而是先写到缓存，当用户付款成功后再写入数据库。
#
#显示秒杀商品列表环境搭建
#
#1新建模块module,创服务接口用jar,选择父类,pom.xml引入pojo的依赖
#
#2服务实现,用war,加依赖,修改端口等,修改web.xml
#
#3加spring配置文件夹,修改端口,修改dubbox(前三个是服务层)
#
#4web层,建war,加依赖,修改端口
#
#5加web.xml并修改
#
#6加spring配置文件夹,修改dubox服务(记得spring的安全框架的东西要在,记得检查)
#
#7拷静态页面到web层的src/webapp/web-inf下面
#
#8拷AngularJS等插件到web层的src/webapp/plugins
#
#9代码生成器
#
#10建包,生成的文件拷过去
#
#11把pojo实现可序列化接口
#
#开始写后端代码
#
#1在服务层接口添加方法,然后在服务层实现
#
#2在服务层条件查询秒杀商品(审核通过,库存大于0,开始日期小于等于当前日期,截止日期大于等于当前日期)
#
#3在web层引入服务层
#
#4该写前端了,在web层,把base.js拷入src/webapp/js下
#
#5src/webapp/js下创建service文件夹,然后创建文件aaaservice.js,调用后端控制层代码
#
#6src/webapp/js下创建control文件夹然后创建文件aaacontrol.js,调用前端服务层层代码
#
#7写页面,先引入js,秒杀控制层js,秒杀服务层js,base,js,angular.min.js的头
#
#8在<body>里面写ng-app="项目名",ng-control="引入的控制层的名",ng-init="初始化查询?"
#
#9在需要的地方添加ng-repeat
#
#10在需要的地方写变量{{pojo.xxx}}绑定变量
#
#11pojo安装下,inteface安装下,service启动下,web启动下
#
#12改错误,然后去web.xml改跳转页面
#
#13因为之前从数据库拿效率低,服务器压力大,所以把第一次数据库查出来的遍历放进缓存()
#
#14去控制层注入查出来的数据变量
#
#接下来写秒杀详情页面,从缓存中读取出商品id,返回一个entity
#
#15去web层写前端,把id传回来
#
#16接收id,然后传id
#
#不写了麻烦自己看
#
##?id={{}}在链接中传参数
#
#定时操作,纯前端解决,这里用angularJS
#
#$interval
#
#然后秒数用方法转格式,用方法converTiomeString
#
#第二十天
#
#任务调度springtask,自动服务调用
#
#在企业级应用中，经常会制定一些“计划任务”，即在某个时间点做某件事情，核心是以时间为关注点，即在一个特定的时间点，系统执行指定的一个操作。常见的任务调度框架有Quartz和SpringTask等。(Quartz会复杂一些)
#
#cron表达式,定义时间规则,可以百度生产器
#
#MavenProfile,实现不同环境的动态切换
#
#Profile用户配置文件
#
#在common里面写dubbox,注册中心地址集中配置,为后面集群搭建方便
#
#数据库MongoDB
#
#MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热门的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似JSON  的 BSON 格式，因此可以存储比较复杂的数据类型。
#
#什么时候用呢??一般,数据量大的时候,或者对数据库频繁写入的时候,数据量价值不是特别高的情况下
#
#比如订单,什么的很重要,就不能用mongodb,比如评价,足迹,日志就可以用这个mongodb
#
#和redis比,redis能存的不大啊,这个大啊
#MongoDB简介
#3.1什么是MongoDB
#
#MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热门的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似JSON  的 BSON 格式，因此可以存储比较复杂的数据类型。
#
#MongoDB 的官方网站地址是：http://www.mongodb.org/
#
#
#MongoDB特点
#
#MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它是一个面向集合的,模式自由的文档型数据库。
#
#具体特点总结如下：
#
#（1）面向集合存储，易于存储对象类型的数据
#
#（2）模式自由
#
#（3）支持动态查询
#
#（4）支持完全索引，包含内部对象
#
#（5）支持复制和故障恢复
#
#（6）使用高效的二进制数据存储，包括大型对象（如视频等）
#
#（7）自动处理碎片，以支持云计算层次的扩展性
#
#（8）支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++语言的驱动程序，社区中也提供了对 Erlang 及.NET 等平台的驱动程序
#
#（9） 文件存储格式为 BSON（一种 JSON 的扩展）
#MongoDB体系结构
#
#MongoDB 的逻辑结构是一种层次结构。主要由：
#
#文档(document)、集合(collection)、数据库(database)这三部分组成的。逻辑结构是面向用户
#
#的，用户使用 MongoDB 开发应用程序使用的就是逻辑结构。
#
#（1）MongoDB 的文档（document），相当于关系数据库中的一行记录。
#
#（2）多个文档组成一个集合（collection），相当于关系数据库的表。
#
#（3）多个集合（collection），逻辑上组织在一起，就是数据库（database）。
#
#（4）一个 MongoDB 实例支持多个数据库（database）。
#
#
#
#品优购电商系统部署
#
#第一天(集群解决方案)
#
#集群,一台计算机承载的能力是有限的,找一堆来分担
#
#节点,集群中的一个计算机
#
#搭建三种
#
#1Zookeeper集群
#
#2SolrCloud集群
#
#3RedisCluster集群
#
#
#集群的特点
#
#
#
#集群拥有以下两个特点：
#
#
#
#1.   可扩展性：集群的性能不限制于单一的服务实体，新的服务实体可以动态的添加到集群，从而增强集群的性能。
#
#
#
#2.   高可用性：集群当其中一个节点发生故障时，这台节点上面所运行的应用程序将在另一台节点被自动接管，消除单点故障对于增强数据可用性、可达性和可靠性是非常重要的。
#
#
#集群的两大能力
#
#
#
#集群必须拥有以下两大能力：
#
#
#
#1.     负载均衡：负载均衡把任务比较均匀的分布到集群环境下的计算和网络资源，以提高数据吞吐量。
#
#
#
#2.     错误恢复：如果集群中的某一台服务器由于故障或者维护需要无法使用，资源和应用程序将转移到可用的集群节点上。这种由于某个节点的资源不能工作，另一个可用节点中的资源能够透明的接管并继续完成任务的过程，叫做错误恢复。
#
#
#
#负载均衡和错误恢复要求各服务实体中有执行同一任务的资源存在，而且对于同一任务的各个资源来说，执行任务所需的信息视图必须是相同的。
#
#
#集群与分布式的区别
#
#相同点：
#
#分布式和集群都是需要有很多节点服务器通过网络协同工作完成整体的任务目标。
#
#不同点：
#
#分布式是指将业务系统进行拆分，即分布式的每一个节点都是实现不同的功能。而集群每个节点做的是同一件事情。
#
#Zookeeper集群,提供分布式锁服务,用以协调分布式应用,所以说zookeeper是分布式应用的协作服务
#
#选举,看中间
#Zookeeper集群简介
#2.1.1为什么搭建Zookeeper集群
#
#大部分分布式应用需要一个主控、协调器或者控制器来管理物理分布的子进程。目前，大多数都要开发私有的协调程序，缺乏一个通用机制，协调程序的反复编写浪费，且难以形成通用、伸缩性好的协调器，zookeeper提供通用的分布式锁服务，用以协调分布式应用。所以说zookeeper是分布式应用的协作服务。
#
#
#
#zookeeper作为注册中心，服务器和客户端都要访问，如果有大量的并发，肯定会有等待。所以可以通过zookeeper集群解决。
#
#
#
#真实的集群是搭建在服务器上的,测试时候启动十几个虚拟机内存吃不消,所以我们会搭建伪集群,把所有服务器搭建在一台虚拟机上,用端口区分
#
#为了提高选举效率,尽可能奇数
#
#FTP远程连接
#
#
#
#SolrCloud集群
#
#dev开发环境,pro生产环境
#
#SolrCloud(solr 云)是 Solr 提供的分布式搜索方案，当你需要大规模，容错，分布式索引和检索能力时使用 SolrCloud。当一个系统的索引数据量少的时候是不需要使用 SolrCloud的，当索引量很大，搜索请求并发很高，这时需要使用 SolrCloud 来满足这些需求。
#
#SolrCloud 是基于 Solr 和Zookeeper的分布式搜索方案，它的主要思想是使用 Zookeeper作为集群的配置信息中心。
#
#
#什么是Redis-Cluster
#
#
#
#为何要搭建Redis集群。Redis是在内存中保存数据的，而我们的电脑一般内存都不大，这也就意味着Redis不适合存储大数据，适合存储大数据的是Hadoop生态系统的Hbase或者是MogoDB。Redis更适合处理高并发，一台设备的存储能力是很有限的，但是多台设备协同合作，就可以让内存增大很多倍，这就需要用到集群。
#
#
#
#Redis集群搭建的方式有多种，例如使用客户端分片、Twemproxy、Codis等，但从redis 3.0之后版本支持redis-cluster集群，它是Redis官方提出的解决方案，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。
#
#
#
#客户端与 redis 节点直连,不需要中间 proxy 层.客户端不需要连接集群所有节点连接集群中任何一个可用节点即可。
#
#
#
#所有的 redis 节点彼此互联(PING-PONG 机制),内部使用二进制协议优化传输速度和带宽.
#
#
#容错机制-投票
#
#
#
#（1）选举过程是集群中所有master参与,如果半数以上master节点与故障节点通信超过(cluster-node-timeout),认为该节点故障，自动触发故障转移操作.  故障节点对应的从节点自动升级为主节点
#
#
#
#（2）什么时候整个集群不可用(cluster_state:fail)?
#
#
#
#如果集群任意master挂掉,且当前master没有slave.集群进入fail状态,也可以理解成集群的slot映射[0-16383]不完成时进入fail状态.
#
#
#
#
#
#第二天
#
#Mycat数据库中间件
#
#Nginx
#
#keepalived 是集群管理中保证集群高可用的一个服务软件，用来防止单点故障。
#
#Keepalived 的作用是检测 web 服务器的状态，如果有一台 web 服务器死机，或工作出现故障，Keepalived 将检测到，并将有故障的 web 服务器从系统中剔除，当 web 服务器工作正常后 Keepalived 自动将 web 服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的 web 服务器。
#
#反向代理用于服务端的
#
#正向代理用于客户主要
#
#web工程由于nginx做反向代理实现负载均衡
#
#服务工程由zookerper负责负载均衡
#
#第三天
#
#Docker容器技术,客户端是操作服务端的
#
#虚拟机已死,容器才是未来
#
#镜像:相当容器的源代码,里面有的都装好了,其实是一组文件的集合
#
#用注册中心来保存用户的镜像
#
#镜像是静态的东西,相当模板,用这个模板创建容器(相当于容器是个副本),容器是运行的东西
#
#Docker建在linux系统上,(官方推荐是Ubuntu上)
#
#使用CentOS.x以上的版本
#
#容器启动的基础是镜像,docker引导镜像成为内存的空间,容器
#
#拉取镜像,就是下载镜像
